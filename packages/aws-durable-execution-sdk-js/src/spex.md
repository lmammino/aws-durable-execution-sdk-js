### Identifying each block

We have to choices for identifying each block (step):

1. Order of blocks: In this way we implicitly create an id for each block by order of executing blocks. the first block will be 1 and so on.
2. Customer will assign a unique name (id) to each block.

We are going with option 2 for now. also to improve develover experience we have some optional congif for naming each block:

```
export interface NameObject {
    name: string;
    iterationKey: string;
    previousStep?: string;
    parentStep?: string;
}
```

`iterationKey` will be used to group similar blocks but for different iteration together.
`previousStep` and `parentStep` will be used to visualize execution graph.
Metrics will be emitted with `name` but raw log will use both `name` and `iterationKey`

Using this custom naming object is optional and customer have 2 choices:

pass simple name as string:

```
run<T>(name: string, fn: RunFunc<T>, options?: RunOptions<T>): Promise<T>;
```

Or pass nameing object:

```
    run<T>(nameObj: NameObject, fn: RunFunc<T>, options?: RunOptions<T>): Promise<T>;
```

<details>
  <summary>Detail on Language SDK spec</summary>

export type Resource<I,O> = string;

export type RunFunc<T> = () => Promise<T> | T;

export interface RetryConfig {
maxAttempts?: number;
maxRetryDurationMillis?: number;
initialDelayMillis?: number;
maxDelayMillis? : number;
exponentialDelayFactor? : number;
shouldRetry?: (error: Error) => boolean;
// TODO: probably other retry options
};

export interface PollingConfig<T> {
intervalMillis: number,
maxPollDuration?: number,
completeWhen?: (result: T) => boolean;
// TODO: probably other polling options
};

export interface RunOptions<T> {
/\*_ Retry config for errors _/
readonly retryConfig?: RetryConfig;

    /** Polling config */
    readonly pollingConfig?: PollingConfig<T>;

};

export interface NameObject {
name: string;
iterationKey: string;
previousStep?: string;
parentStep?: string;
}

export interface Context {
// This is the base lambda Context
// as described in
// https://docs.aws.amazon.com/lambda/latest/dg/typescript-context.html
}

export interface DurableContext extends Context {

    /**
     * The ID of this invocation - will remain constant across re-invocations.
     * It is generated by DAR
     */
    readonly invocationId: InvocationId;

    // TODO: There may need to be additional fields here for passing request metadata
    //       (E.g. information about retry count, headers, etc)

    /**
     * Durably run a block of code and persist its result so that it does
     * not run to completion more than once (only will run more than once for
     * retriable failures/results, subject to optional retry config)
     */
    run<T>(name: string, fn: RunFunc<T>, options?: RunOptions<T>): Promise<T>;
    run<T>(nameObj: NameObject, fn: RunFunc<T>, options?: RunOptions<T>): Promise<T>;


    /**
     * Returns a DurablePromise that will resolve after the specified number of milliseconds has passed, unless
     * it is cancelled.
     */
    wait(name: string, millis: number): DurablePromise<void>;
    wait(nameObj: NameObject, millis: number): DurablePromise<void>;

    /**
     * Create a durable promise that can be awaited on, and an id that can be
     * used to complete that promise externally (like waitForTaskToken in
     * step functions)
     */
    durablePromise<T>(name: string): [DurablePromise<T>, string];
    durablePromise<T>(nameObj: NameObject): [DurablePromise<T>, string];

    /**
     * Resolve a durable promise by its id
     */
    resolveDurablePromise<T>(id: string, value: T): void;

    /**
     * Reject a durable promise by its id
     */
    rejectDurablePromise(id: string, reason: string): void;

    /**
     * Invoke another durable function, returning a promise that will complete
     * when that invocation completes.
     *
     * Has built-in idempotency / exactly once execution
     */
    invoke<I,O>(name: string, funcId: FunctionIdentifier, input: I, options?: InvokeOptions): DurablePromise<O>;
    invoke<I,O>(nameObj: NameObject, funcId: FunctionIdentifier, input: I, options?: InvokeOptions): DurablePromise<O>;

    /**
     * Invoke another durable function asynchronously, not waiting for any response, optionally
     * with a delay. This is a Fire-and-forget call, but ensures that it _is_ invoked
     *
     * Has built-in idempotency / exactly once execution
     */
    invokeAsync<I>(name: string, funcId: FunctionIdentifier, input: I, options?: InvokeAsyncOptions): InvocationId;
    invokeAsync<I>(nameObj: NameObject, funcId: FunctionIdentifier, input: I, options?: InvokeAsyncOptions): InvocationId;

    /**
     * Invoke an AWS service connector.
     *
     * Basically Step Functions task state.
     *
     * TODO: Do we want/need this
     */
    invokeConnector<I,O>(name: string,resource: Resource<I,O>, input: I, options?: InvokeOptions): DurablePromise<O>;
    invokeConnector<I,O>(nameObj: NameObject, resource: Resource<I,O>, input: I, options?: InvokeOptions): DurablePromise<O>;

    //
    // Helpers for common use cases to avoid non-determinism
    //

    /**
     * Get the Clock instance for this invocation
     */
    readonly clock: Clock;

    /**
     * Get the Log instance for this invocation
     */
    readonly log: Log;

    /**
     * Get the Random instance for this invocation
     */
    readonly random: Random;

}

/\*\*

- These StatefulDurableContext interfaces are for more advanced potential use cases involving
- multi-handler / shared state - Workflows and Durable Objects
  _/
  export interface StatefulDurableContext extends DurableContext {
  /\*\*
  _ The identifier of this specific function instance
  \*/
  readonly id: EntityId;
  }

export interface SharedStatefulDurableContext extends StatefulDurableContext {
/\*\*
_ Create a durable promise that is local to this function instance and can only
_ be completed from one of its handlers (e.g. like a signal) \*
_ This is effectively like the non-local createPromise() except here the name can be
_ provided and referenced directly (scoped to the "instance") without having to pass
_ a promise "id" (i.e. task token) around. And the promise can actually be retrieved
_ before it is created.
\*/
localDurablePromise<T>(name: string): CompletableDurablePromise<T>;

    /**
     * Get a value from the object state.
     */
    getState<T>(key: string): Promise<T>;

}

export interface ExclusiveStatefulDurableContext extends SharedStatefulDurableContext {
/\*\*
_ Set a key in the function instance state.
_/
setState<T>(key: string, value: T): void;

    /**
     * Unset a key in the function instance state.
     */
    clearState(key: string): void;

};

</details>

_APIs used in Language SDK_

We are communicating from Language SDK and our service with 2 APIs

1. getStepData: return data for checkpointed blocks, SDK will use it to replay blocks and also find out which block did not executed before.
   getStepData will return a key value pairs. for each block we have a stepId that is created from block name.

2. checkpoint: for persisting data for each block

<details>
   <summary>Detail of getStepData and checkpoint methods</summary>

**POST getStepData**

request parameters:

```
stepId?: string,
nextToken?: string,
maxResult?: number
```

response:

```
type StepType = 'run' | 'wait' | 'durablePromise' | 'invoke' | 'invokeAsync';

interface StepInfo {
    stepName: string;
    iterationKey: string;
    type: StepType;
    config: any;
    data: any;
    result: string;
    error: string;
    status: string;
}

interface getStepDataResponse {
    stepData: {
        [stepId: string]: StepInfo;
    };
    nextToken: string;
}

```

**POST checkpoint**

request parameters:

```
stepId?: string,
taskToken: string,
stepName: string;
type: StepType;
config?: any; // Only the initial checkpoint for each step needs config
result: string;
error: string;
status: string;
```

response:

```
    taskToken: string // new task token to use in next checkpoint call
```

</details>

### TaskToken

To gurantee we don't invoke the same block more than once instead of executionId or executionArn we will use tasksToken.
tasksToken has additional data on top of executionId and we will use it to call checkpoint method.

### Lambda invocation event

When DAR service calls customer function, it will pass some meta tag, so language SDK can find the durable invocation and replay and continue executing it.

event:

```
executionId: string
taskToken: string
iinvocationData: object // initial invocation data
stateDate: getStepDataResponse

```

In each invocation of Lambda, DAR service will pass the first page of result for getStepData API, this way language SDK does not need to call getStepData at begining.

### How replay works

- When we start invocation, we will be in replay mode.
- For each block we check if it exist in initial getStepData
- If it exist:
  - Check the status for the block
    - If it finished, we replay, and we stay in replay mode.
    - If it started but not finished, then we will retry. the replay mode will ends
- If it does not exist, we need to call getStepData to get more data.
- We add received data to our existing data
- If the exist:
  - Check the status for the block
    - If it finished, we replay, and we stay in replay mode.
    - If it started but not finished, then we will retry. the replay mode will ends
- If it does not exist, replay mode will end

### How checkpointing works

- When we start a block or finished a block we call checkpoint method
- Checkpoint API needs taskToken and also return a new taskToken.
- We will update taskToken and use it for next checkpoint calls.
- If for any reason the checkpoint call fails (4xx or 5xx), we terminate the invocation.
